# Analyse


```{r, setup_analysis, echo=FALSE, warning=FALSE, message=FALSE}

suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(purrr)
  library(pbmcapply)
  library(kknn)
  library(tidyr)
})

source("R/03-analysis.R")

# TODO: remove
quotes_line <- readRDS("tmp/quotes_line.rds")

```

Für die Analyse der Daten mit dem Ziel einen Kaufs- sowie einen Verkaufkurs zu prognostizieren, bei dem der Delta-Hedge nachgezogen werden soll, werden nachfolgend verschiedene Techniken eingesetzt. Diese sind:

- Einfache Optimierungen
- KLassifikationsverfahren (bsp. KNN):
- Neuronale Netzwerke (bsp. RNN, LTSM):
- Autogressive Modelle (bsp. GARCH)


## Einfache Optimierungen

Eine einfache Möglichkeit, optimale Kaufs- und Verkaufspreise zu finden besteht darin, diese im Testdatensatz mittels einfacher Optimierung zu evaluieren. In einer ersten sehr einfachen Evaluation bietet es sich an, die Kaufs- und Verkaufsmarken als optimierte prozentuale Bewegungen vom aktuellen Preis zu ermitteln. Dies lässt sich sowohl symmetrische wie auch asymmetrisch machen. 

```{r, echo=FALSE}
# 
dat <- drop_na(quotes_line)

#' opt_payoff_sym(0, quotes_test)
opt_payoff_sym <- function(move, quotes_line, col = "Open", scale_fct = 1) {
  sum(calc_payoff_const_gamma(quotes_line, buy = (1 - move) * quotes_line[[col]], sell = (1 + move) * quotes_line[[col]], both_first = "buy")) / scale_fct
}

opt_payoff_sym(move = 0.01, quotes_line = dat, col = "Adjusted_t_1", scale_fct = sum(calc_payoff_const_gamma(dat, both_first = "buy")))


move <- seq(0, 0.2, 0.0025)
factor_open <- unlist(pbmclapply(X = move, FUN = opt_payoff_sym, quotes_line = dat, mc.cores = 2, col ="Open", scale_fct = sum(calc_payoff_const_gamma(dat, both_first = "buy"))))
factor_adjusted_t_1 <- unlist(pbmclapply(X = move, FUN = opt_payoff_sym, quotes_line = dat, mc.cores = 2, col ="Adjusted_t_1", scale_fct = sum(calc_payoff_const_gamma(dat, both_first = "buy"))))

res <- tibble(move = move, factor = factor_adjusted_t_1)

plot(res$move, res$factor, type = "l")
```







## Klassifikationsverfahren

```{r, train_test_split, echo=FALSE}
set.seed(1234)
train_idx <- sample(seq_len(nrow(quotes_line)), floor(0.2 * nrow(quotes_line)))
test_idx <- sample(setdiff(seq_len(nrow(quotes_line)), train_idx), floor(0.01 * nrow(quotes_line)))

data_wide <- widen(quotes_line, 5, feature_cols = c("Low"), target_col = NULL)
date <- quotes_line$Date






low_train <- low_all[train_idx, ]
low_test <- low_all[test_idx, ]

high_all <- widen(quotes_line, 10, feature_cols = c("Open", "Low", "High", "Close"), target_col = "High")
high_train <- high_all[train_idx, ]
high_test <- high_all[test_idx, ]

```



```{r, kknn, echo=FALSE}

start <- Sys.time()
model_low <- kknn(Low~., low_train, low_test)
end <- Sys.time()
end - start

# model_low_hash <- digest::digest(model_low)
# file_model_low <- here::here(paste0("tmp/model_low_", model_low_hash,".rds"))
# saveRDS(model_low, file_model_low)

start <- Sys.time()
model_high <- kknn(High~., high_train, high_test)
end <- Sys.time()
end - start

# model_high_hash <- digest::digest(model_high)
# file_model_high <- here::here(paste0("tmp/model_high_", model_high_hash,".rds"))
# saveRDS(model_high, file_model_high)


### some quick tests

var(high_test$High - mean(fitted(model_high)))
var(high_test$High - fitted(model_high))

var(low_test$Low - mean(fitted(model_low)))
var(low_test$Low - fitted(model_low))


a <- calc_payoff_const_gamma(quotes_line[test_idx, ])
sum(a)

b <- calc_payoff_const_gamma(quotes_line[test_idx, ], buy = fitted(model_low), sell = fitted(model_high), both_first = "max")
factor <- sum(b) / sum(a)

control_group <- calc_payoff_const_gamma(quotes_line[test_idx, ], buy = quotes_line$Low[test_idx], sell = quotes_line$High[test_idx], both_first = "min")
sum(control_group)


```

```{r, fnn, echo=FALSE}


```

## Neuronale Netzwerke

## Autoregressive Modelle
