# Analyse


```{r, setup_analysis, echo=FALSE, warning=FALSE, message=FALSE}

suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(purrr)
  library(pbmcapply)
  library(kknn)
  library(tidyr)
  library(ggplot2)
})

source("R/03-analysis.R")

# TODO: remove
quotes_line <- readRDS("tmp/quotes_line.rds")

```

Für die Analyse der Daten mit dem Ziel einen Kaufs- sowie einen Verkaufkurs zu prognostizieren, bei dem der Delta-Hedge nachgezogen werden soll, werden nachfolgend verschiedene Techniken eingesetzt. Diese sind:

- Einfache Optimierungen
- KLassifikationsverfahren (bsp. KNN):
- Neuronale Netzwerke (bsp. RNN, LTSM):
- Autogressive Modelle (bsp. GARCH)


## Einfache Optimierungen

Eine einfache Möglichkeit, optimale Kaufs- und Verkaufspreise zu finden besteht darin, diese im Testdatensatz mittels einfacher Optimierung zu evaluieren. In einer ersten sehr einfachen Evaluation bietet es sich an, die Kaufs- und Verkaufsmarken als optimierte prozentuale Bewegungen vom aktuellen Preis zu ermitteln. Dies lässt sich sowohl symmetrische wie auch asymmetrisch machen. 

```{r, echo=FALSE}
# 


#' opt_payoff_sym(0, quotes_test)
opt_payoff_sym <- function(move, quotes_line, col = "Open", scale_fct = 1) {
  sum(calc_payoff_const_gamma(quotes_line, buy = (1 - move) * quotes_line[[col]], sell = (1 + move) * quotes_line[[col]], both_first = "buy")) / scale_fct
}

dat <- drop_na(quotes_line)

opt_payoff_sym(move = 0.01, quotes_line = quotes_line, scale_fct = sum(calc_payoff_const_gamma(quotes_line, both_first = "buy")))


move <- seq(0, 0.2, 0.0025)
factor_open <- unlist(pbmclapply(X = move, FUN = opt_payoff_sym, quotes_line = dat, mc.cores = 2, col ="Open", scale_fct = sum(calc_payoff_const_gamma(dat, both_first = "buy"))))
factor_adjusted_t_1 <- unlist(pbmclapply(X = move, FUN = opt_payoff_sym, quotes_line = dat, mc.cores = 2, col ="Adjusted_t_1", scale_fct = sum(calc_payoff_const_gamma(dat, both_first = "buy"))))

res <- tibble(move = move, factor = factor_adjusted_t_1)

plot(res$move, res$factor, type = "l")
```






## Klassifikationsverfahren
```{r, train_test_split, echo=FALSE}

quotes_line <- tidyr::drop_na(quotes_line)

      # out <- find_nn(quotes_line = quotes_line, cols = c("Open", "Low", "High", "Close"), window = 3, norm = "euclidean", mc.cores = 3)
# saveRDS(out, "tmp/knn_olhc_3_euc.rds")
# rm(out)

#out <- find_nn(quotes_line = quotes_line, cols = c("Open", "Low", "High", "Close"), window = 3, norm = "manhattan", mc.cores = 3)
# saveRDS(out, "tmp/knn_olhc_3_man.rds")


knn_olhc_3_euc <- readRDS("tmp/knn_olhc_3_euc.rds")
knn_olhc_3_man <- readRDS("tmp/knn_olhc_3_man.rds")


plot_history <- function(id, data, window, nn_idx) {


  
  
  comp %>%
    mutate(entry = seq_len(n())) %>%
    tidyr::pivot_longer(-entry, names_to = "type")

  
  cols_all <- paste0(cols, "_", seq_len(ncol(data) / length(cols)))
  data_id <- map(seq_len(ncol(data) / length(cols)), ~select_at(data, paste0(cols, "_", .)))
  
  
cols_all <- do.call(function(...) paste(..., sep = "_"), expand.grid(cols, seq_len(ncol(data) / length(cols))))

  curr_data <- data_id[[1]] %>% 
    mutate(id = seq_len(n())) %>%
    tidyr::pivot_longer(-id, names_to = "type") %>%
    mutate_at("type", ~factor(., levels = cols_all)) %>%
    filter(id < 10)
    
    

  ggplot(data=filter(dat, ID %in% seq_len(51)), aes(x=type, y=value, group = ID)) + 

  
  ggplot(data=filter(dat, ID %in% seq_len(51)), aes(x=type, y=value, group = ID)) + 
  geom_point() + 
  geom_line() +
  theme_bw()
  
  

}


x <- quotes_line[123456, ]
foo <- knn_olhc_3_euc$nn.idx[123456, ]
foo <- knn_olhc_3_man$nn.idx[123456, ]

test <- arrange(quotes_line, Ticker, Date)

data_wide_123456 <- data_query$data_wide

quotes_line[123453:123455,]

data_wide_123456[foo, ]

quotes_line[21352,]


dat <- x %>%
  bind_rows(quotes_line[foo, ]) %>%
  select("Open", "Low", "High", "Close") %>%
  mutate(ID = seq_len(n())) %>% 
  tidyr::pivot_longer(-ID, names_to = "type")

ggplot(data=filter(dat, ID %in% seq_len(51)), aes(x=type, y=value, group = ID)) + 
  geom_point() + 
  geom_line() +
  theme_bw()
  
  
```




```{r, kknn, echo=FALSE}

data_wide_0 <- quotes_line %>%
  group_by(Ticker) %>%
  widen(window = 3, cols = c("Open", "Low", "High", "Close"), include_current = TRUE)

id <- 1234
quotes_line[id, ]
data_wide_0[id, ]

out <- find_nn(data_wide_0[1:10000, setdiff(names(data_wide_0), paste0(c("Open", "Low", "High", "Close"), "_", 0))], dates = quotes_line$Date[1:10000])

plot_nn(data_wide_0[id, ], data_wide_0[out$nn.idx[id, 1:10], ])

```

```{r, fnn, echo=FALSE}


```

## Neuronale Netzwerke

## Autoregressive Modelle
