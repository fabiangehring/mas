# Analyse


```{r message=FALSE, warning=FALSE, setup_analysis, echo=FALSE}

suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(purrr)
  library(pbmcapply)
  library(tidyr)
  library(ggplot2)
  library(data.table)
  library(dtplyr)
  library(arrow)
  library(microbenchmark)
  library(profvis)
})
Rcpp::sourceCpp('src/bootstrap_nn_idx.cpp')
source("R/03-analysis.R")

# TODO: remove
quotes_line <- arrow::read_feather("tmp/quotes_line.feather")

```

Für die Analyse der Daten mit dem Ziel einen Kaufs- sowie einen Verkaufkurs zu prognostizieren, bei dem der Delta-Hedge nachgezogen werden soll, werden nachfolgend verschiedene Techniken eingesetzt. Diese sind:

- Einfache Optimierungen
- KLassifikationsverfahren (bsp. KNN):
- Neuronale Netzwerke (bsp. RNN, LTSM):
- Autogressive Modelle (bsp. GARCH)


## Einfache Optimierungen

Eine einfache Möglichkeit, optimale Kaufs- und Verkaufspreise zu finden besteht darin, diese im Testdatensatz mittels einfacher Optimierung zu evaluieren. In einer ersten sehr einfachen Evaluation bietet es sich an, die Kaufs- und Verkaufsmarken als optimierte prozentuale Bewegungen vom aktuellen Preis zu ermitteln. Dies lässt sich sowohl symmetrische wie auch asymmetrisch machen. 

```{r, echo=FALSE}
# 
# #' opt_payoff_sym(0, quotes_test)
# opt_payoff_sym <- function(move, quotes_line, col, both_first, scale_fct = 1) {
#   sum(calc_payoff_const_gamma(quotes_line, buy = (1 - move) * quotes_line[[col]], sell = (1 + move) * quotes_line[[col]], both_first = both_first)) / scale_fct
# }
# 
# both_first <- 123456
# dat <- tidyr::drop_na(quotes_line)
# opt_payoff_sym(move = 0.01, quotes_line = dat, col = "Open", both_first = both_first, scale_fct = sum(calc_payoff_const_gamma(dat, both_first = both_first)))
# 
# move <- seq(0, 0.1, 0.0025)
# 
# factor_open <- dplyr::map(
#   .x = move,
#   .f = opt_payoff_sym,
#   quotes_line = dat,
#   col = "Open",
#   both_first = both_first,
#   scale_fct = sum(calc_payoff_const_gamma(dat, both_first = both_first))
# )
# 
# optimum_open <- optimize(
#   f = opt_payoff_sym,
#   interval = c(0, 0.2),
#   quotes_line = dat,
#   col = "Open",
#   both_first = both_first,
#   scale_fct = sum(calc_payoff_const_gamma(dat, both_first = both_first)),
#   maximum = TRUE
# )
# 
# res_open <- tibble(move = move, factor = unlist(factor_open))
# plot(res_open$move, res_open$factor, type = "l")
# 
# 
# factor_adjusted_t_1 <- map(
#   .x = move,
#   .f = opt_payoff_sym,
#   quotes_line = dat,
#   col = "Adjusted_t_1",
#   both_first = both_first,
#   scale_fct = sum(calc_payoff_const_gamma(dat, both_first = both_first))
# )
# 
# optimum_adjusted_t_1 <- optimize(
#   f = opt_payoff_sym,
#   interval = c(0, 0.2),
#   quotes_line = dat,
#   col = "Adjusted_t_1",
#   both_first = both_first,
#   scale_fct = sum(calc_payoff_const_gamma(dat, both_first = both_first)),
#   maximum = TRUE
# )
# 
# res_adjusted_t_1 <- tibble(move = move, factor = unlist(factor_adjusted_t_1))
# plot(res_adjusted_t_1$move, res_adjusted_t_1$factor, type = "l")
# 

```


## Klassifikationsverfahren
```{r, train_test_split, echo=FALSE}
# 
# quotes_line <- tidyr::drop_na(quotes_line)
# 
# # out <- find_nn(quotes_line = quotes_line, cols = c("Open", "Low", "High", "Close"), window = 3, norm = "euclidean", mc.cores = 3)
# # saveRDS(out, "tmp/knn_olhc_3_euc.rds")
# # rm(out)
# 
# #out <- find_nn(quotes_line = quotes_line, cols = c("Open", "Low", "High", "Close"), window = 3, norm = "manhattan", mc.cores = 3)
# # saveRDS(out, "tmp/knn_olhc_3_man.rds")
# 
# 
# knn_olhc_3_euc <- readRDS("tmp/knn_olhc_3_euc.rds")
# knn_olhc_3_man <- readRDS("tmp/knn_olhc_3_man.rds")
# 
# 
# plot_history <- function(id, data, window, nn_idx) {
#   
#   
#   test <- sample(1000:2000, 15000, replace = TRUE)
#   
#   
#   
#   comp %>%
#     mutate(entry = seq_len(n())) %>%
#     tidyr::pivot_longer(-entry, names_to = "type")
#   
#   
#   cols_all <- paste0(cols, "_", seq_len(ncol(data) / length(cols)))
#   data_id <- map(seq_len(ncol(data) / length(cols)), ~select_at(data, paste0(cols, "_", .)))
#   
#   
#   cols_all <- do.call(function(...) paste(..., sep = "_"), expand.grid(cols, seq_len(ncol(data) / length(cols))))
#   
#   curr_data <- data_id[[1]] %>% 
#     mutate(id = seq_len(n())) %>%
#     tidyr::pivot_longer(-id, names_to = "type") %>%
#     mutate_at("type", ~factor(., levels = cols_all)) %>%
#     filter(id < 10)
#   
#   
#   
#   ggplot(data=filter(dat, ID %in% seq_len(51)), aes(x=type, y=value, group = ID)) + 
#     
#     
#     ggplot(data=filter(dat, ID %in% seq_len(51)), aes(x=type, y=value, group = ID)) + 
#     geom_point() + 
#     geom_line() +
#     theme_bw()
#   
#   
#   
# }
# 
# 
# x <- quotes_line[123456, ]
# foo <- knn_olhc_3_euc$nn.idx[123456, ]
# foo <- knn_olhc_3_man$nn.idx[123456, ]
# 
# test <- arrange(quotes_line, Ticker, Date)
# 
# data_wide_123456 <- data_query$data_wide
# 
# quotes_line[123453:123455,]
# 
# data_wide_123456[foo, ]
# 
# quotes_line[21352,]
# 
# 
# dat <- x %>%
#   bind_rows(quotes_line[foo, ]) %>%
#   select("Open", "Low", "High", "Close") %>%
#   mutate(ID = seq_len(n())) %>% 
#   tidyr::pivot_longer(-ID, names_to = "type")
# 
# ggplot(data=filter(dat, ID %in% seq_len(51)), aes(x=type, y=value, group = ID)) + 
#   geom_point() + 
#   geom_line() +
#   theme_bw()
# 

```



```{r, knn-calculation, echo=FALSE}
# data_wide_0 <- quotes_line %>%
#   as_tibble() %>%
#   group_by(Ticker) %>%
#   widen(window = 3, cols = c("Open", "Low", "High", "Close"), include_current = TRUE)
# 
# # exclude all columns (also when _0 value is not available)
# na_rows_bool <- rowSums(is.na(data_wide_0)) > 0
# knn_data <- data_wide_0 %>%
#   mutate(Date = quotes_line$Date) %>%
#   mutate_all(~ifelse(na_rows_bool, NA, .)) 
# 
# gc()
# nn <- find_nn(select(knn_data, !c(ends_with("_0"), any_of("Date"))), dates = knn_data$Date, mc.cores = 3)
# 
# 
# nn <- readRDS("data/nn_eucl_olhc_w3_38a896430298c738055505dc89e042ac.rds")
# 
# nn <- readRDS("data/nn_eucl_olhc_w3_38a896430298c738055505dc89e042ac.rds")
# 
# 
# 

```


```{r, knn-history-plot, echo=FALSE}
# id <- 280000
# valid_idx <- seq_len(n)[rowSums(is.na(nn$nn.idx)) == 0]
# 
# k <- 10
# plot_nn(data_wide_0[valid_idx[id], ], data_wide_0[nn$nn.idx[valid_idx[id], seq_len(k)],])

```

```{r, knn-prediction-power, echo=FALSE}
# k <- 20
# 
# nn_idx <- as.matrix(arrow::read_arrow("data/nn_idx_eucl_olhc_w3_38a896430298c738055505dc89e042ac.feather"))
# 
# nn_pred <- pred_nn(select(data_wide_0, c("Low_0", "High_0")), nn_idx = nn_idx[, seq_len(k)])
# na_row_bool <- rowSums(is.na(nn_pred)) > 0
# 
# nn_pred_sample <- nn_pred[!na_row_bool, ] %>% rename(Buy = Low_0, Sell = High_0)
# quotes_line_sample <- quotes_line[!na_row_bool, ]
# 
# plot_ratio_history(quotes_line = quotes_line_sample, data_pred = nn_pred_sample)
# 
# 
# ### perform bootstraping
# size_map <- quotes_line %>%
#   select(Date) %>%
#   group_by(Date) %>% 
#   summarize(count = n()) %>% 
#   ungroup() %>% 
#   mutate(size = cumsum(count) - count) %>% 
#   select(-count)
# size <- quotes_line %>% select(Date) %>% left_join(size_map, by = "Date") %>% .[["size"]]
# ###
# 
# boot_nn_idx_1 <- bootstrap_nn_idx(nn_idx, size, 20, 123456)
# 
# nn_pred_boot <- pred_nn(select(data_wide_0, c("Low_0", "High_0")), nn_idx = boot_nn_idx_1)
# na_row_bool_boot <- rowSums(is.na(nn_pred_boot)) > 0
# 
# nn_pred_boot_sample <- nn_pred_boot[!na_row_bool_boot, ] %>% rename(Buy = Low_0, Sell = High_0)
# quotes_line_boot_sample <- quotes_line[!na_row_bool_boot, ]
# 
# plot_ratio_history(quotes_line = quotes_line_boot_sample, data_pred = nn_pred_boot_sample)
# 
# 

```



```{r, knn-bootstraping, echo=FALSE}
# k <- 20
# quotes_line <- readRDS("tmp/quotes_line.rds")
# quotes_line_sorted <- quotes_line %>% arrange(Date)
# 
# nn_idx <- arrow::read_arrow("data/nn_idx_eucl_olhc_w3_38a896430298c738055505dc89e042ac.feather")
# 
# nn_idx_sorted <- readRDS("data/nn_eucl_olhc_w3_38a896430298c738055505dc89e042ac.rds") %>% .[["nn.idx"]] %>% sort_nn_idx(quotes_line$Date)
# 
# 
# set.seed(123456)
# boot_pred <- map(seq_len(100), function(i) {
#   print(i)
#   curr_nn_idx_boot <- bootstrap_nn(sort(quotes_line$Date), sort_nn_idx(nn_idx_sorted), k = k)
#   pred_nn(select(quotes_line_sorted, c("Low", "High")), nn_idx = curr_nn_idx_boot)
# })
# # saveRDS(boot_pred, "tmp/boot_pred.rds")
# 
# boot_pred <- readRDS("tmp/boot_pred.rds")
# 
# 
# all_complete <- rep(TRUE, nrow(quotes_line_sorted))
# for(i in seq_along(boot_pred)) {
#   print(i)
#   all_complete <- all_complete * rowSums(is.na(boot_pred[[i]])) == 0
#   gc()
# }
# 
# na_row_bool <- rowSums(is.na(nn_idx_sorted)) + rowSums(is.na())
# 
# test <- map(boot_pred, ~sum(calc_payoff_const_gamma(quotes_line_sorted[all_complete], buy = .$Low, sell = .$High, both_first = 234567)))
# 
# na_row_bool <- rowSums(is.na(nn$nn.idx)) == 0

# nn_idx[4418184, ]
# quotes_line[4418184, ]




```

## Neuronale Netzwerke

## Autoregressive Modelle
