# Analyse


```{r, setup_analysis, echo=FALSE, warning=FALSE, message=FALSE}

suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(purrr)
  library(pbmcapply)
  library(kknn)
  library(tidyr)
})

source("R/03-analysis.R")

# TODO: remove
quotes_line <- readRDS("tmp/quotes_line.rds")

```

Für die Analyse der Daten mit dem Ziel einen Kaufs- sowie einen Verkaufkurs zu prognostizieren, bei dem der Delta-Hedge nachgezogen werden soll, werden nachfolgend verschiedene Techniken eingesetzt. Diese sind:

- Einfache Optimierungen
- KLassifikationsverfahren (bsp. KNN):
- Neuronale Netzwerke (bsp. RNN, LTSM):
- Autogressive Modelle (bsp. GARCH)


## Einfache Optimierungen

Eine einfache Möglichkeit, optimale Kaufs- und Verkaufspreise zu finden besteht darin, diese im Testdatensatz mittels einfacher Optimierung zu evaluieren. In einer ersten sehr einfachen Evaluation bietet es sich an, die Kaufs- und Verkaufsmarken als optimierte prozentuale Bewegungen vom aktuellen Preis zu ermitteln. Dies lässt sich sowohl symmetrische wie auch asymmetrisch machen. 

```{r, echo=FALSE}
# 
opt_payoff_sym <- function(move, quotes_line) {
  sum(calc_payoff_const_gamma(quotes_line, buy = (1 - move) * quotes_line$Adjusted_t_1, sell = (1 + move) * quotes_line$Adjusted_t_1))
}

sum(calc_payoff_const_gamma(quotes_line, buy = quotes_line$Low, sell = quotes_line$High)) / sum(calc_payoff_const_gamma(quotes_line))

sum(calc_payoff_const_gamma(quotes_line, buy = quotes_line$Low, sell = quotes_line$High, both_first = "max")) / sum(calc_payoff_const_gamma(quotes_line))
sum(calc_payoff_const_gamma(quotes_line, buy = quotes_line$Low, sell = quotes_line$High, both_first = "min")) / sum(calc_payoff_const_gamma(quotes_line))
sum(calc_payoff_const_gamma(quotes_line, buy = quotes_line$Low, sell = quotes_line$High, both_first = 123)) / sum(calc_payoff_const_gamma(quotes_line))


move <- seq(0, 1, 0.005)
factor <- unlist(pbmclapply(move,  opt_payoff_sym, quotes_line = quotes_line, mc.cores = 3))/sum(calc_payoff_const_gamma(quotes_line))
res <- tibble(move = move, factor = factor)

plot(res$move, res$factor, type = "l")
```







## Klassifikationsverfahren

```{r, train_test_split, echo=FALSE}
set.seed(1234)
train_idx <- sample(seq_len(nrow(quotes_line)), floor(0.2 * nrow(quotes_line)))
test_idx <- sample(setdiff(seq_len(nrow(quotes_line)), train_idx), floor(0.01 * nrow(quotes_line)))

data_wide <- widen(quotes_line, 5, feature_cols = c("Low"), target_col = NULL)
date <- quotes_line$Date






low_train <- low_all[train_idx, ]
low_test <- low_all[test_idx, ]

high_all <- widen(quotes_line, 10, feature_cols = c("Open", "Low", "High", "Close"), target_col = "High")
high_train <- high_all[train_idx, ]
high_test <- high_all[test_idx, ]

```



```{r, kknn, echo=FALSE}

start <- Sys.time()
model_low <- kknn(Low~., low_train, low_test)
end <- Sys.time()
end - start

# model_low_hash <- digest::digest(model_low)
# file_model_low <- here::here(paste0("tmp/model_low_", model_low_hash,".rds"))
# saveRDS(model_low, file_model_low)

start <- Sys.time()
model_high <- kknn(High~., high_train, high_test)
end <- Sys.time()
end - start

# model_high_hash <- digest::digest(model_high)
# file_model_high <- here::here(paste0("tmp/model_high_", model_high_hash,".rds"))
# saveRDS(model_high, file_model_high)


### some quick tests

var(high_test$High - mean(fitted(model_high)))
var(high_test$High - fitted(model_high))

var(low_test$Low - mean(fitted(model_low)))
var(low_test$Low - fitted(model_low))


a <- calc_payoff_const_gamma(quotes_line[test_idx, ])
sum(a)

b <- calc_payoff_const_gamma(quotes_line[test_idx, ], buy = fitted(model_low), sell = fitted(model_high), both_first = "max")
factor <- sum(b) / sum(a)

control_group <- calc_payoff_const_gamma(quotes_line[test_idx, ], buy = quotes_line$Low[test_idx], sell = quotes_line$High[test_idx], both_first = "min")
sum(control_group)


```

```{r, fnn, echo=FALSE}

split_data_query <- function(curr_date, all_dates, data_wide) {
  query <- data_wide[all_dates %in% curr_date, ]
  data_wide <- data_wide[all_dates < max(curr_date), ]
  return(list(data_wide = data_wide, query = query))
}


# nn <- calc_nn(quotes_line, "Low", 5)
# View(50 - rowSums(is.na(nn$nn.idx)))
calc_nn <- function(quotes_line, feature_cols, window, k = 50, treetype = "kd") {
  
  data_wide <- quotes_line %>% 
    group_by(Ticker) %>% 
    dplyr::group_modify(~widen(data = ., window = window, feature_cols = feature_cols, target_col = NULL)) %>% 
    ungroup() %>%
    select(-Ticker)
  
  # data_wide <- widen(quotes_line, window, feature_cols = feature_cols, target_col = NULL)
  all_dates <- quotes_line$Date
  
  # remove NA values
  na_free_row_bool <- rowSums(is.na(data_wide)) == 0
  data_wide <- data_wide[na_free_row_bool, ]
  all_dates <- all_dates[na_free_row_bool]
  
  # order dates such that indizes are strictly increasing
  date_order <- order(all_dates)
  all_dates <- all_dates[date_order]
  data_wide <- data_wide[date_order, ]
  
  unique_dates <- sort(unique(all_dates))
  
  chunk_size <- 20
  n_chunks <- ceiling(length(unique_dates) / chunk_size)
  date_chunks <- split(unique_dates, head(rep(seq_len(n_chunks), each = chunk_size), length(unique_dates)))
  
  knn_output <- pbmcapply::pbmclapply(date_chunks, function(curr_date_chunk) {
    data_query <- split_data_query(curr_date_chunk, all_dates, data_wide)
    out <- RANN::nn2(data_query$data_wide, query = data_query$query, min(k, nrow(data_query$data_wide)), treetype = treetype)
    if (nrow(data_query$data_wide) < k) {
      tmp <- matrix(rep(NA, k * nrow(data_query$query)), ncol = k)
      nn.idx <- tmp
      nn.idx[, seq_len(nrow(data_query$data_wide))] <- out[["nn.idx"]]
      nn.dists <- tmp
      nn.dists[, seq_len(nrow(data_query$data_wide))] <- out[["nn.dists"]]
      out <- list(nn.idx = nn.idx, nn.dists = nn.dists)
    }
    return(out)
  }, mc.cores = parallel::detectCores() - 1)
  
  nn <- list()
  nn[["nn.idx"]] <- purrr::map(knn_output,  ~.[["nn.idx"]]) %>% do.call(rbind, .)
  nn[["nn.dists"]] <- purrr::map(knn_output,  ~.[["nn.dists"]]) %>% do.call(rbind, .)
  
  # make sure all neighbors are from previous dates
  neighbor_date_minus_self_date <- matrix(all_dates[nn[["nn.idx"]]], ncol = k) - as.integer(all_dates)
  nn[["nn.idx"]][neighbor_date_minus_self_date >= 0] <- NA
  nn[["nn.dists"]][neighbor_date_minus_self_date >= 0] <- NA
  
  nn
}

```

## Neuronale Netzwerke

## Autoregressive Modelle
